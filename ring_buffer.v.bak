module ring_buffer #(
    parameter RAM_WIDTH = 8,
    parameter RAM_DEPTH = 256
)(
    input  wire                   clk,
    input  wire                   rst,

    // Write port
    input  wire                   wr_en,
    input  wire [RAM_WIDTH-1:0]   wr_data,

    // Read port
    input  wire                   rd_en,
    output reg                    rd_valid,
    output reg  [RAM_WIDTH-1:0]   rd_data,

    // Flags
    output wire                   empty,
    output wire                   empty_next,
    output wire                   full,
    output wire                   full_next,

    // Number of elements
    output reg [$clog2(RAM_DEPTH):0] fill_count
);

    // Memory
    reg [RAM_WIDTH-1:0] ram [0:RAM_DEPTH-1];

    // Pointers
    reg [$clog2(RAM_DEPTH)-1:0] head;
    reg [$clog2(RAM_DEPTH)-1:0] tail;

    // Internal signals
    wire empty_i;
    wire full_i;

    // Increment with wrap
    function [$clog2(RAM_DEPTH)-1:0] incr;
        input [$clog2(RAM_DEPTH)-1:0] index;
        begin
            if (index == RAM_DEPTH-1)
                incr = 0;
            else
                incr = index + 1;
        end
    endfunction

    // Flags
    assign empty_i    = (fill_count == 0);
    assign empty      = empty_i;
    assign empty_next = (fill_count <= 1);

    assign full_i     = (fill_count >= RAM_DEPTH-1);
    assign full       = full_i;
    assign full_next  = (fill_count >= RAM_DEPTH-2);

    // Head pointer update (write)
    always @(posedge clk) begin
        if (rst) begin
            head <= 0;
        end else if (wr_en && !full_i) begin
            ram[head] <= wr_data;
            head <= incr(head);
        end
    end

    // Tail pointer update (read)
    always @(posedge clk) begin
        if (rst) begin
            tail <= 0;
            rd_valid <= 0;
        end else begin
            rd_valid <= 0;
            if (rd_en && !empty_i) begin
                rd_data  <= ram[tail];
                tail     <= incr(tail);
                rd_valid <= 1;
            end
        end
    end

    // Fill count update (combinational)
    always @(*) begin
        if (head < tail)
            fill_count = head - tail + RAM_DEPTH;
        else
            fill_count = head - tail;
    end

endmodule
